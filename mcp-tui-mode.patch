diff --git a/crates/wonopcode/src/main.rs b/crates/wonopcode/src/main.rs
index b569453..fixed 100644
--- a/crates/wonopcode/src/main.rs
+++ b/crates/wonopcode/src/main.rs
@@ -612,6 +612,15 @@ async fn run_command(
         }
     }

+    // Start background MCP HTTP server for Claude CLI integration
+    let (mcp_url, mcp_server_handle) = match start_mcp_server(cwd).await {
+        Ok((url, handle)) => (Some(url), Some(handle)),
+        Err(e) => {
+            tracing::warn!(error = %e, "Failed to start MCP server, Claude CLI will not use custom tools");
+            (None, None)
+        }
+    };
+
     // Create runner config
     let config = RunnerConfig {
         provider: provider.clone(),
@@ -623,7 +632,7 @@ async fn run_command(
         doom_loop: wonopcode_core::permission::Decision::Ask,
         test_provider_settings: None,
         allow_all: false,
-        mcp_url: None, // No custom MCP tools in TUI mode
+        mcp_url, // Use background MCP server for custom tools
     };

     // Create runner with snapshot support
@@ -730,6 +739,11 @@ async fn run_command(
     // Shutdown
     let _ = action_tx.send(wonopcode_tui::AppAction::Quit);
     runner_handle.abort();
+
+    // Shutdown MCP server
+    if let Some(handle) = mcp_server_handle {
+        handle.abort();
+    }
     instance.dispose().await;

     Ok(())
@@ -1636,6 +1650,15 @@ async fn run_interactive(cwd: &std::path::Path, cli: Cli) -> anyhow::Result<()>
         }
     }

+    // Start background MCP HTTP server for Claude CLI integration
+    let (mcp_url, mcp_server_handle) = match start_mcp_server(cwd).await {
+        Ok((url, handle)) => (Some(url), Some(handle)),
+        Err(e) => {
+            tracing::warn!(error = %e, "Failed to start MCP server, Claude CLI will not use custom tools");
+            (None, None)
+        }
+    };
+
     // Create runner config
     let config = RunnerConfig {
         provider: provider.clone(),
@@ -1647,7 +1670,7 @@ async fn run_interactive(cwd: &std::path::Path, cli: Cli) -> anyhow::Result<()>
         doom_loop: wonopcode_core::permission::Decision::Ask,
         test_provider_settings: None,
         allow_all: false,
-        mcp_url: None, // No custom MCP tools in TUI mode
+        mcp_url, // Use background MCP server for custom tools
     };

     // Get MCP config from config file
@@ -1679,6 +1702,12 @@ async fn run_interactive(cwd: &std::path::Path, cli: Cli) -> anyhow::Result<()>
         .await?;
     }

+    // Shutdown MCP server
+    if let Some(handle) = mcp_server_handle {
+        handle.abort();
+        // Give it a moment to shutdown gracefully
+        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
+    }
     // Cleanup
     instance.dispose().await;

@@ -2962,6 +2991,62 @@ impl wonopcode_mcp::McpToolExecutor for ToolExecutorWrapper {
     }
 }

+/// Start a background HTTP server for MCP tools.
+///
+/// This starts an HTTP server on a random available port that serves only the MCP endpoints.
+/// Returns the MCP SSE URL and a server handle that can be used to shutdown the server.
+///
+/// # Arguments
+/// * `cwd` - Working directory for the MCP server
+///
+/// # Returns
+/// A tuple of (mcp_sse_url, server_handle) where:
+/// - `mcp_sse_url` is the URL to use for MCP connections (e.g., "http://127.0.0.1:12345/mcp/sse")
+/// - `server_handle` is a tokio task handle for the server (can be aborted to shutdown)
+async fn start_mcp_server(
+    cwd: &std::path::Path,
+) -> anyhow::Result<(String, tokio::task::JoinHandle<()>)> {
+    use axum::Router;
+    use tower_http::cors::{Any, CorsLayer};
+    use wonopcode_mcp::create_mcp_router;
+
+    // Bind to a random available port
+    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await?;
+    let local_addr = listener.local_addr()?;
+
+    info!(address = %local_addr, "Starting background MCP HTTP server");
+
+    // Build the URL for the MCP message endpoint
+    let mcp_message_url = format!("http://{}/mcp/message", local_addr);
+
+    // Create MCP state
+    let mcp_state = create_mcp_http_state(cwd, &mcp_message_url).await?;
+
+    // Create router with just MCP endpoints
+    let mcp_router = create_mcp_router(mcp_state);
+
+    let cors = CorsLayer::new()
+        .allow_origin(Any)
+        .allow_methods(Any)
+        .allow_headers(Any);
+
+    let app = Router::new()
+        .nest("/mcp", mcp_router)
+        .layer(cors);
+
+    // Build the SSE URL to return
+    let mcp_sse_url = format!("http://{}/mcp/sse", local_addr);
+
+    // Spawn the server in the background
+    let server_handle = tokio::spawn(async move {
+        if let Err(e) = axum::serve(listener, app).await {
+            tracing::error!(error = %e, "MCP HTTP server error");
+        }
+        info!("MCP HTTP server shutdown");
+    });
+
+    info!(mcp_url = %mcp_sse_url, "MCP HTTP server started");
+
+    Ok((mcp_sse_url, server_handle))
+}
+
 /// Create MCP HTTP state for the headless server.
 ///
 /// This sets up the MCP tools to be served over HTTP/SSE instead of stdio,
